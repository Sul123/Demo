# Executors framework

## Введение

В задачах первого семинара вам нужно было распараллелить вычисления задач.
Если немного обобщить, то код всех ваших решений выглядел примерно так:

```c++

class Output;
class Input;

Output Compute(const Input& inputs) {
    // Select concurrency level
    int num_threads = std::thread::hardware_concurrency();

    // Split input into tasks
    std::vector<Tasks> tasks = SplitIntoSubtasks(inputs, num_threads);

    // Launch threads
    std::vector<std::thread> threads;
    for (int i = 0; i < num_threads; ++i) {
        threads.emplace_back([i, &inputs, &tasks] {
            ComputeSubtask(&tasks[i], input);
        });
    }

    // Join all threads
    for (auto& t : threads) t.join();

    // Aggregate
    return Aggregate(tasks, input);
}
```

Если внимательно посмотреть на код, то можно заметить, что в нём смешаны 2
независимых действия:
  
    1. Большая задача разбивается на небольшие независимые подзадачи. Затем
       решения подзадач объединяются вместе. Этот код специфичен для каждого алгоритма.

    2. Код решает сколько потоков запускать, как их запускать и когда
       их завершать. Этот код везде одинаковый.

С первым пунктом все хорошо, а вот со вторым есть проблемы.

  * Пользователь не может контролировать сколько потоков будет запущено.
    _Код действует эгоистично и занимает все ядра на машине._

  * Неудобно использовать такой код внутри другого параллельного алгоритма.
    _Например если на первом уровне разобъем задачу на 10 частей и каждую захотим решить с помощью `Compute()`, то у нас запустится `10 * hardware concurrency` потоков._

  * Нельзя отменить вычисление, нельзя следить за прогрессом.

Все проблемы появляются из того, что код сам занимается созданием
потоков. Мы хотим вынести это решение на самый высокий уровень, а в
коде оставить только разбиение на независимые подзадачи. В этом
задании вам нужно написать библиотеку помогающую выполнить такое разделение.

### Executors и Tasks

**Disclaimer:** интерфейсы Task и Executor в этой задаче не претендуют
  на элегантность и эффективность.

  * `Task` - это какой-то кусок вычислений. Сам код вычисления находится в
  методе run() и определяется пользователем.
  * `Executor` - это набор потоков, которые могут выполнять `Task`-и. 
  * `Executor` *должен* запускать потоки в конструкторе, во время работы новых потоков создаваться не должно.
  * Чтобы начать выполнять `Task`, пользователь должен отправить его в `Executor` с помощью метода
  `submit()`.
  * После этого, пользователь может дождаться пока `Task` завершится, позвав метод `Task::wait`.

  ```c++
  class MyPrimeSplittingTask : public Task {
      Params params_;
  public:
      MyPrimeSplittingTask(Params params) : params_(params) {}
      bool is_prime = false;
      virtual void run() {
          is_prime = check_is_prime(params_);
      }
  }

  bool doComputation(std::shared_ptr<Executor> pool, Params params) {
      auto my_task = std::make_shared<MyPrimeSplittingTask>(params);
      pool->submit(my_task);
      my_task.wait();
      return my_task->is_prime;
  }
  ```

  * `Task` может завершиться успешно (`isCompleted`), с ошибкой
    (`isFailed`) и быть отменён (`isCanceled`). После того, как с ним
    произошло одно из этих событий - он считается выполненным
    (`isFinished`).

  * Пользователь может в любой момент отменить `Task` с помощью метода
    `cancel()`. В этом случае, если выполнение `Task`а еще не
    началось, то оно и не должно начаться.

  * `Task` может иметь зависимости. Например в задаче reduce сначала
    должны были выполниться reduce-ы по кускам вектора, а потом один
    финальный reduce по промежуточным значениям. Пользователь может
    сказать, что один `Task` должен выполняться только после того как
    выполнился какой-то другой `Task`, позвав метод
    `Task::addDependency`.

  * `Task` может иметь триггеры (`Task::addTrigger`). В таком случае он должен начать
    выполнение после того как хотя бы один триггер завершился.

  * `Task` может иметь один триггер по времени
    (`Task::setTimeTrigger`). В этом случае он должен начать
    выполнение если наступило время `deadline`.

  * В общем случае, `Executor::submit` не должен начинать выполнение
    сразу, а дожидаться условия:
      - _Или_ есть зависомости и все они выполнились
      - _Или_ один из триггеров выполнился
      - _Или_ выставлен `deadline`, и наступило время `deadline`.
    Если у таска нет зависимостей, нет триггеров и не выставлен deadline,
    то его можно выполнять сразу же.

  * `Executor` предоставляет API для того, чтобы остановить выполнение.
      - `Executor::startShutdown` - начинает процесс остановки. Таски, которые 
        были посланы после `startShutdown` должны сразу переходить в состояние canceled.
      - `Executor::waitShutdown` - блокируется, пока Executor не остановится.
      - `Executor::~Executor` - неявно делает shutdown и дожидается завершения потоков.

### Futures

Интерфейсы `Task` и `Executor` являются довольно многословными, во второй
части задания вам нужно будет реализовать класс `Future` и несколько комбинаторов к нему.

  * `Future` - это `Task`, у которого есть результат (какое-то значение).

  * Интерфейсы комбинаторов определены в классе `Executor`:
    - `invoke(cb)` - выполнить `cb` внутри `Executor`-а, результат вернуть через `Future`.
    - `then(input, cb)` - выполнить `cb`, после того как закончится `input`. Возвращает `Future` на результат `cb` не дожидаясь выполнения `input`.
    - `whenAll(vector<FuturePtr<T>> ) -> FuturePtr<vector<T>>` - собирает результат нескольких `Future` в один.
    - `whenFirst(vector<FuturePtr<T>>) -> FuturePtr<T>` - возвращает результат, который появится первым.
    - `whenAllBeforeDeadline(vector<FuturePtr<T>>, deadline) -> FuturePtr<vector<T>>` - возвращает все результаты, которые успели появиться до deadline.

## Советы по реализации

  1. Продумайте какие lock-и вам потребуются. Как сделать так, чтобы
     в них не было циклов?
  2. Продумайте в каких состояниях может находиться `Task`. Вставьте в
     код `assert`-ы.
  3. Начните с базового функционала: `Task`-и `Executor` без
     зависимостей и триггеров. Затем реализуйте зависимости и
     триггеры, поверх этого реализуйте `Future` и комбинаторы.
  4. Для реализации таймеров вам потребуется использовать метод
     `wait_until` у `std::condition_variable`.
  5. Для эффективной реализации таймеров нужно использовать кучу.
  6. Чтобы управлять памятью без утечек вам потребуется использовать `std::weak_ptr` и `std::enable_shared_from_this`.